// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  output        = "../generated/client"
  engineType    = "binary"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/////////////// USER MODELS ///////////////

model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  password String
  pseudo   String @unique

  avatar Avatar?

  role      String    @default("user")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Relations
  friends            Friend[]             @relation("UserFriends")
  friend             Friend[]             @relation("FriendUser")
  userStats          UserStats?
  userEvents         UserEvent[]
  gameResults        GameResult[]
  PasswordResetToken PasswordResetToken[]
  vipSubscriptions   VipSubscription[]
}

model VipSubscription {
  id     Int  @id @default(autoincrement())
  userId Int
  user   User @relation(fields: [userId], references: [id])

  stripeSubscriptionId String? // si abonnement actif
  stripeCustomerId     String? // si on veut garder une trace

  plan        VipPlan // "monthly" | "yearly"
  startDate   DateTime
  endDate     DateTime?
  cancelledAt DateTime?
  status      VipStatus // active | cancelled | expired

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum VipPlan {
  monthly
  yearly
}

enum VipStatus {
  active
  cancelled
  expired
}

model PasswordResetToken {
  token     String   @id
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  expiresAt DateTime
}

model Avatar {
  id             Int    @id @default(autoincrement())
  url            String
  shapeId        Int
  eyesId         Int
  mouthId        Int
  patternId      Int?
  colorShapeId   Int
  colorPatternId Int?

  // Relations
  shape   AvatarAsset  @relation("Shape", fields: [shapeId], references: [id])
  eyes    AvatarAsset  @relation("Eyes", fields: [eyesId], references: [id])
  mouth   AvatarAsset  @relation("Mouth", fields: [mouthId], references: [id])
  pattern AvatarAsset? @relation("Pattern", fields: [patternId], references: [id])

  colorShape   Color  @relation("ColorShape", fields: [colorShapeId], references: [id])
  colorPattern Color? @relation("ColorPattern", fields: [colorPatternId], references: [id])

  // Relations
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique
}

model Color {
  id            Int     @id @default(autoincrement())
  name          String
  value         String
  gradientValue String? // Dégradé de couleur (ex: "linear-gradient(to right, #ff0000, #0000ff)")
  level         Int     @default(0) // Niveau requis
  vip           Boolean @default(false)

  // Relations
  colorShape   Avatar[] @relation("ColorShape")
  colorPattern Avatar[] @relation("ColorPattern")
}

model AvatarAsset {
  id      Int     @id @default(autoincrement())
  type    String // "shape", "eyes", "mouth", "color", "pattern"
  name    String
  url     String
  level   Int     @default(0) // Niveau requis
  vipOnly Boolean @default(false)

  // Relations
  shapes   Avatar[] @relation("Shape")
  eyes     Avatar[] @relation("Eyes")
  mouths   Avatar[] @relation("Mouth")
  patterns Avatar[] @relation("Pattern")

  // Relations
  userEvents UserEvent[]
}

model Friend {
  id        Int       @id @default(autoincrement())
  userId    Int
  friendId  Int
  status    String    @default("pending") // "pending", "accepted", "rejected"
  createdAt DateTime  @default(now())
  deletedAt DateTime? // ✅ Soft delete

  // Relations
  user       User        @relation("UserFriends", fields: [userId], references: [id])
  friend     User        @relation("FriendUser", fields: [friendId], references: [id])
  userEvents UserEvent[]

  @@unique([userId, friendId]) // ✅ Évite les doublons
}

model UserStats {
  id           Int       @id @default(autoincrement())
  userId       Int       @unique
  xp           Int       @default(0)
  level        Int       @default(1)
  streak       Int       @default(0)
  lastPlayedAt DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model UserEvent {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String // "level_up", "streak_bonus", "game_completed"
  createdAt DateTime @default(now())

  // Relations possible des événements
  avatarAssetId Int? // ID de l'asset d'avatar concerné (si applicable)
  avatarAsset   AvatarAsset? @relation(fields: [avatarAssetId], references: [id])
  friendId      Int? // ID de l'ami concerné (si applicable)
  friend        Friend?      @relation(fields: [friendId], references: [id])
  gameResultId  Int? // ID du résultat de jeu (si applicable)
  gameResult    GameResult?  @relation(fields: [gameResultId], references: [id])

  // Infos supplémentaires
  levelUp  Int? // Niveau atteint lors de cet événement
  attempts Int? // Nombre d'essais pour un jeu

  user User @relation(fields: [userId], references: [id])
}

/////////////////////////////////////////////

/////////////// GAME MODELS ///////////////

model GameResult {
  id        Int       @id @default(autoincrement())
  userId    Int
  gameId    Int
  score     Int
  xpGained  Int       @default(0) // XP gagné lors de cette partie
  status    String // "passed" ou "failed"
  date      DateTime  @default(now())
  deletedAt DateTime? // ✅ Soft delete

  // Relations
  user       User        @relation(fields: [userId], references: [id])
  game       Game        @relation(fields: [gameId], references: [id])
  userEvents UserEvent[]

  @@index([score]) // ✅ Index pour accélérer les classements
  @@index([date]) // ✅ Index pour accélérer les filtres par période
}

model Game {
  id             Int          @id @default(autoincrement())
  name           String
  description    String       @default("Trouver le film") // Description du jeu
  imgUrl         String? // URL de l'image du jeu
  path           String       @default("game-cinema-1") // Chemin du jeu (pour l'API)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  deletedAt      DateTime? // ✅ Soft delete
  gameCategoryId Int
  gameCategory   GameCategory @relation(fields: [gameCategoryId], references: [id])
  status         String       @default("available") // "available", "coming_soon", "unavailable"

  results GameResult[]
}

model GameCategory {
  id        Int       @id @default(autoincrement())
  name      String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // ✅ Soft delete
  color     String?   @default("red") // Couleur de la catégorie (pour l'interface)

  games Game[]
}

/////////////////////////////////////////////

/////////////// DATA MODELS ///////////////

model DataMovie {
  id            Int      @id @default(autoincrement())
  tmdbId        Int      @unique // ID du film sur TMDB
  title         String
  originalTitle String
  year          Int
  releaseDate   DateTime
  runtime       Int? // Durée du film en minutes
  director      String? // Réalisateur
  actors        String? // Acteurs principaux séparés par des virgules
  genres        String // Liste des genres (ex: "Action, Aventure, Sci-Fi")
  synopsis      String? // Résumé du film
  production    String? // Studios de production séparés par des virgules
  country       String? // Pays de production
  language      String? // Langue principale du film
  voteAverage   Float?
  voteCount     Int?
  popularity    Float?
  budget        Int? // Budget du film
  keywords      String? // Mots-clés du film, séparés par des virgules
  posterPath    String? // URL du poster TMDB
  backdropPath  String? // URL de l'image de fond TMDB

  // ✅ Liste des images du film (pour les jeux basés sur les images)
  image1  String?
  image2  String?
  image3  String?
  image4  String?
  image5  String?
  image6  String?
  image7  String?
  image8  String?
  image9  String?
  image10 String?

  createdAt DateTime @default(now())

  // Relation avec GameCinema1Days (films sélectionnés pour un jour de jeu)
  gameDays  GameCinema1Days[]
  gameDays2 GameCinema2Days[]
}

/////////////////////////////////////////////

/////////////// GAME CINEMA 1 ///////////////

model GameCinema1Days {
  id        Int       @id @default(autoincrement())
  date      DateTime  @unique // Un jour ne peut avoir qu'un seul film
  movieId   Int // 
  movie     DataMovie @relation(fields: [movieId], references: [id])
  createdAt DateTime  @default(now())

  // Relation avec les essais des joueurs
  tries GameCinema1Tries[]
}

model GameCinema1Tries {
  id        Int      @id @default(autoincrement())
  userId    Int
  dayId     Int
  guess     String
  correct   Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relation avec le jour du jeu
  day GameCinema1Days @relation(fields: [dayId], references: [id])
}

/////////////// GAME CINEMA 2 ///////////////
model GameCinema2Days {
  id        Int       @id @default(autoincrement())
  date      DateTime  @unique // Un jour ne peut avoir qu'un seul film
  movieId   Int
  movie     DataMovie @relation(fields: [movieId], references: [id])
  createdAt DateTime  @default(now())

  // Relation avec les essais des joueurs
  tries GameCinema2Tries[]
}

model GameCinema2Tries {
  id        Int      @id @default(autoincrement())
  userId    Int
  dayId     Int
  guess     String
  correct   Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relation avec le film du jeu
  day GameCinema2Days @relation(fields: [dayId], references: [id])
}

/////////////////////////////////////////////
